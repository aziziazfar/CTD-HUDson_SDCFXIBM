{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\hahahazzry\\\\Desktop\\\\classification-react\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _slicedToArray from \"C:\\\\Users\\\\hahahazzry\\\\Desktop\\\\classification-react\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\hahahazzry\\\\Desktop\\\\classification-react\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport * as tf from \"@tensorflow/tfjs\";\nconst TYPE_DETECTION = \"detection\";\nconst TYPE_CLASSIFICATION = \"classification\";\n\nconst calculateMaxScores = (scores, numBoxes, numClasses) => {\n  const maxes = [];\n  const classes = [];\n\n  for (let i = 0; i < numBoxes; i++) {\n    let max = Number.MIN_VALUE;\n    let index = -1;\n\n    for (let j = 0; j < numClasses; j++) {\n      if (scores[i * numClasses + j] > max) {\n        max = scores[i * numClasses + j];\n        index = j;\n      }\n    }\n\n    maxes[i] = max;\n    classes[i] = index;\n  }\n\n  return [maxes, classes];\n};\n\nconst buildDetectedObjects = (width, height, boxes, scores, indexes, classes, labels) => {\n  const count = indexes.length;\n  const objects = [];\n\n  for (let i = 0; i < count; i++) {\n    const bbox = [];\n\n    for (let j = 0; j < 4; j++) {\n      bbox[j] = boxes[indexes[i] * 4 + j];\n    }\n\n    const minY = bbox[0] * height;\n    const minX = bbox[1] * width;\n    const maxY = bbox[2] * height;\n    const maxX = bbox[3] * width;\n    bbox[0] = minX;\n    bbox[1] = minY;\n    bbox[2] = maxX - minX;\n    bbox[3] = maxY - minY;\n    objects.push({\n      bbox: bbox,\n      class: labels[parseInt(classes[indexes[i]])],\n      // deprecate.\n      label: labels[parseInt(classes[indexes[i]])],\n      score: scores[indexes[i]]\n    });\n  }\n\n  return objects;\n};\n\nconst runObjectDetectionPrediction = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(graph, labels, input, {\n    maxNumberOfBoxes = 20,\n    iouThreshold = 0.5,\n    scoreThreshold = 0.5\n  } = {}) {\n    var batched, height, width, result, scores, boxes, _calculateMaxScores, _calculateMaxScores2, maxScores, classes, prevBackend, indexTensor, indexes;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          batched = tf.tidy(() => {\n            const img = tf.browser.fromPixels(input); // Reshape to a single-element batch so we can pass it to executeAsync.\n\n            return img.expandDims(0);\n          });\n          height = batched.shape[1];\n          width = batched.shape[2];\n          _context.next = 5;\n          return graph.executeAsync(batched);\n\n        case 5:\n          result = _context.sent;\n          scores = result[0].dataSync();\n          boxes = result[1].dataSync(); // clean the webgl tensors\n\n          batched.dispose();\n          tf.dispose(result);\n          _calculateMaxScores = calculateMaxScores(scores, result[0].shape[1], result[0].shape[2]), _calculateMaxScores2 = _slicedToArray(_calculateMaxScores, 2), maxScores = _calculateMaxScores2[0], classes = _calculateMaxScores2[1];\n          prevBackend = tf.getBackend(); // run post process in cpu\n\n          tf.setBackend(\"cpu\");\n          indexTensor = tf.tidy(() => {\n            const boxes2 = tf.tensor2d(boxes, [result[1].shape[1], result[1].shape[3]]);\n            return tf.image.nonMaxSuppression(boxes2, maxScores, maxNumberOfBoxes, iouThreshold, scoreThreshold);\n          });\n          indexes = indexTensor.dataSync();\n          indexTensor.dispose(); // restore previous backend\n\n          tf.setBackend(prevBackend);\n          return _context.abrupt(\"return\", buildDetectedObjects(width, height, boxes, maxScores, indexes, classes, labels));\n\n        case 18:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n\n  return function runObjectDetectionPrediction(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nconst runClassificationPrediction = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(graph, labels, input, options = {}) {\n    var batched, results, scores, finalScores;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          batched = tf.tidy(() => {\n            const img = tf.browser.fromPixels(input);\n            const small = tf.image.resizeBilinear(img, [224, 224]).div(255); // Reshape to a single-element batch so we can pass it to executeAsync.\n\n            return small.expandDims(0).toFloat();\n          });\n          results = graph.execute({\n            Placeholder: batched\n          });\n          scores = results.arraySync()[0];\n          results.dispose();\n          batched.dispose();\n          finalScores = scores.map((score, i) => ({\n            label: labels[i],\n            score: score\n          }));\n          finalScores.sort((a, b) => b.score - a.score);\n          return _context2.abrupt(\"return\", finalScores);\n\n        case 8:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n\n  return function runClassificationPrediction(_x4, _x5, _x6) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nconst CONTROL_FLOW_OPS = [\"Switch\", \"Merge\", \"Enter\", \"Exit\", \"NextIteration\"];\nconst DYNAMIC_SHAPE_OPS = [\"NonMaxSuppressionV2\", \"NonMaxSuppressionV3\", \"Where\"];\n\nconst checkControlFlow = graph => {\n  return Object.values(graph.executor.graph.nodes).find(n => CONTROL_FLOW_OPS.includes(n.op)) !== undefined;\n};\n\nexport default {\n  load: function () {\n    var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(path) {\n      var graphPath, labelsPath, graphPromise, labelsPromise, _yield$Promise$all, _yield$Promise$all2, graph, labels, hasControlFlowOps;\n\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            graphPath = path + \"/model.json\";\n            labelsPath = path + \"/labels.json\";\n            graphPromise = tf.loadGraphModel(graphPath);\n            labelsPromise = fetch(labelsPath).then(data => data.json());\n            _context5.next = 6;\n            return Promise.all([graphPromise, labelsPromise]);\n\n          case 6:\n            _yield$Promise$all = _context5.sent;\n            _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n            graph = _yield$Promise$all2[0];\n            labels = _yield$Promise$all2[1];\n            hasControlFlowOps = checkControlFlow(graph); // If there are control flow ops it's probably object detection.\n\n            if (!hasControlFlowOps) {\n              _context5.next = 13;\n              break;\n            }\n\n            return _context5.abrupt(\"return\", {\n              type: TYPE_DETECTION,\n              detect: function () {\n                var _detect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(input, options) {\n                  return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                    while (1) switch (_context3.prev = _context3.next) {\n                      case 0:\n                        _context3.next = 2;\n                        return runObjectDetectionPrediction(graph, labels, input, options);\n\n                      case 2:\n                        return _context3.abrupt(\"return\", _context3.sent);\n\n                      case 3:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }, _callee3);\n                }));\n\n                function detect(_x8, _x9) {\n                  return _detect.apply(this, arguments);\n                }\n\n                return detect;\n              }()\n            });\n\n          case 13:\n            return _context5.abrupt(\"return\", {\n              type: TYPE_CLASSIFICATION,\n              classify: function () {\n                var _classify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(input, options) {\n                  return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                    while (1) switch (_context4.prev = _context4.next) {\n                      case 0:\n                        _context4.next = 2;\n                        return runClassificationPrediction(graph, labels, input, options);\n\n                      case 2:\n                        return _context4.abrupt(\"return\", _context4.sent);\n\n                      case 3:\n                      case \"end\":\n                        return _context4.stop();\n                    }\n                  }, _callee4);\n                }));\n\n                function classify(_x10, _x11) {\n                  return _classify.apply(this, arguments);\n                }\n\n                return classify;\n              }()\n            });\n\n          case 14:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, _callee5);\n    }));\n\n    function load(_x7) {\n      return _load.apply(this, arguments);\n    }\n\n    return load;\n  }()\n};","map":{"version":3,"sources":["C:/Users/hahahazzry/Desktop/classification-react/node_modules/@cloud-annotations/models/src/index.js"],"names":["tf","TYPE_DETECTION","TYPE_CLASSIFICATION","calculateMaxScores","scores","numBoxes","numClasses","maxes","classes","i","max","Number","MIN_VALUE","index","j","buildDetectedObjects","width","height","boxes","indexes","labels","count","length","objects","bbox","minY","minX","maxY","maxX","push","class","parseInt","label","score","runObjectDetectionPrediction","graph","input","maxNumberOfBoxes","iouThreshold","scoreThreshold","batched","tidy","img","browser","fromPixels","expandDims","shape","executeAsync","result","dataSync","dispose","maxScores","prevBackend","getBackend","setBackend","indexTensor","boxes2","tensor2d","image","nonMaxSuppression","runClassificationPrediction","options","small","resizeBilinear","div","toFloat","results","execute","Placeholder","arraySync","finalScores","map","sort","a","b","CONTROL_FLOW_OPS","DYNAMIC_SHAPE_OPS","checkControlFlow","Object","values","executor","nodes","find","n","includes","op","undefined","load","path","graphPath","labelsPath","graphPromise","loadGraphModel","labelsPromise","fetch","then","data","json","Promise","all","hasControlFlowOps","type","detect","classify"],"mappings":";;;AAAA,OAAO,KAAKA,EAAZ,MAAoB,kBAApB;AAEA,MAAMC,cAAc,GAAG,WAAvB;AACA,MAAMC,mBAAmB,GAAG,gBAA5B;;AAEA,MAAMC,kBAAkB,GAAG,CAACC,MAAD,EAASC,QAAT,EAAmBC,UAAnB,KAAkC;AAC3D,QAAMC,KAAK,GAAG,EAAd;AACA,QAAMC,OAAO,GAAG,EAAhB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,QAApB,EAA8BI,CAAC,EAA/B,EAAmC;AACjC,QAAIC,GAAG,GAAGC,MAAM,CAACC,SAAjB;AACA,QAAIC,KAAK,GAAG,CAAC,CAAb;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,UAApB,EAAgCQ,CAAC,EAAjC,EAAqC;AACnC,UAAIV,MAAM,CAACK,CAAC,GAAGH,UAAJ,GAAiBQ,CAAlB,CAAN,GAA6BJ,GAAjC,EAAsC;AACpCA,QAAAA,GAAG,GAAGN,MAAM,CAACK,CAAC,GAAGH,UAAJ,GAAiBQ,CAAlB,CAAZ;AACAD,QAAAA,KAAK,GAAGC,CAAR;AACD;AACF;;AACDP,IAAAA,KAAK,CAACE,CAAD,CAAL,GAAWC,GAAX;AACAF,IAAAA,OAAO,CAACC,CAAD,CAAP,GAAaI,KAAb;AACD;;AACD,SAAO,CAACN,KAAD,EAAQC,OAAR,CAAP;AACD,CAhBD;;AAkBA,MAAMO,oBAAoB,GAAG,CAC3BC,KAD2B,EAE3BC,MAF2B,EAG3BC,KAH2B,EAI3Bd,MAJ2B,EAK3Be,OAL2B,EAM3BX,OAN2B,EAO3BY,MAP2B,KAQxB;AACH,QAAMC,KAAK,GAAGF,OAAO,CAACG,MAAtB;AACA,QAAMC,OAAO,GAAG,EAAhB;;AACA,OAAK,IAAId,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGY,KAApB,EAA2BZ,CAAC,EAA5B,EAAgC;AAC9B,UAAMe,IAAI,GAAG,EAAb;;AACA,SAAK,IAAIV,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1BU,MAAAA,IAAI,CAACV,CAAD,CAAJ,GAAUI,KAAK,CAACC,OAAO,CAACV,CAAD,CAAP,GAAa,CAAb,GAAiBK,CAAlB,CAAf;AACD;;AACD,UAAMW,IAAI,GAAGD,IAAI,CAAC,CAAD,CAAJ,GAAUP,MAAvB;AACA,UAAMS,IAAI,GAAGF,IAAI,CAAC,CAAD,CAAJ,GAAUR,KAAvB;AACA,UAAMW,IAAI,GAAGH,IAAI,CAAC,CAAD,CAAJ,GAAUP,MAAvB;AACA,UAAMW,IAAI,GAAGJ,IAAI,CAAC,CAAD,CAAJ,GAAUR,KAAvB;AACAQ,IAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUE,IAAV;AACAF,IAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUC,IAAV;AACAD,IAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUI,IAAI,GAAGF,IAAjB;AACAF,IAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUG,IAAI,GAAGF,IAAjB;AACAF,IAAAA,OAAO,CAACM,IAAR,CAAa;AACXL,MAAAA,IAAI,EAAEA,IADK;AAEXM,MAAAA,KAAK,EAAEV,MAAM,CAACW,QAAQ,CAACvB,OAAO,CAACW,OAAO,CAACV,CAAD,CAAR,CAAR,CAAT,CAFF;AAEmC;AAC9CuB,MAAAA,KAAK,EAAEZ,MAAM,CAACW,QAAQ,CAACvB,OAAO,CAACW,OAAO,CAACV,CAAD,CAAR,CAAR,CAAT,CAHF;AAIXwB,MAAAA,KAAK,EAAE7B,MAAM,CAACe,OAAO,CAACV,CAAD,CAAR;AAJF,KAAb;AAMD;;AACD,SAAOc,OAAP;AACD,CAhCD;;AAkCA,MAAMW,4BAA4B;AAAA,sEAAG,iBACnCC,KADmC,EAEnCf,MAFmC,EAGnCgB,KAHmC,EAInC;AAAEC,IAAAA,gBAAgB,GAAG,EAArB;AAAyBC,IAAAA,YAAY,GAAG,GAAxC;AAA6CC,IAAAA,cAAc,GAAG;AAA9D,MAAsE,EAJnC;AAAA;;AAAA;AAAA;AAAA;AAM7BC,UAAAA,OAN6B,GAMnBxC,EAAE,CAACyC,IAAH,CAAQ,MAAM;AAC5B,kBAAMC,GAAG,GAAG1C,EAAE,CAAC2C,OAAH,CAAWC,UAAX,CAAsBR,KAAtB,CAAZ,CAD4B,CAE5B;;AACA,mBAAOM,GAAG,CAACG,UAAJ,CAAe,CAAf,CAAP;AACD,WAJe,CANmB;AAY7B5B,UAAAA,MAZ6B,GAYpBuB,OAAO,CAACM,KAAR,CAAc,CAAd,CAZoB;AAa7B9B,UAAAA,KAb6B,GAarBwB,OAAO,CAACM,KAAR,CAAc,CAAd,CAbqB;AAAA;AAAA,iBAedX,KAAK,CAACY,YAAN,CAAmBP,OAAnB,CAfc;;AAAA;AAe7BQ,UAAAA,MAf6B;AAiB7B5C,UAAAA,MAjB6B,GAiBpB4C,MAAM,CAAC,CAAD,CAAN,CAAUC,QAAV,EAjBoB;AAkB7B/B,UAAAA,KAlB6B,GAkBrB8B,MAAM,CAAC,CAAD,CAAN,CAAUC,QAAV,EAlBqB,EAoBnC;;AACAT,UAAAA,OAAO,CAACU,OAAR;AACAlD,UAAAA,EAAE,CAACkD,OAAH,CAAWF,MAAX;AAtBmC,gCAwBN7C,kBAAkB,CAC7CC,MAD6C,EAE7C4C,MAAM,CAAC,CAAD,CAAN,CAAUF,KAAV,CAAgB,CAAhB,CAF6C,EAG7CE,MAAM,CAAC,CAAD,CAAN,CAAUF,KAAV,CAAgB,CAAhB,CAH6C,CAxBZ,iEAwB5BK,SAxB4B,4BAwBjB3C,OAxBiB;AA8B7B4C,UAAAA,WA9B6B,GA8BfpD,EAAE,CAACqD,UAAH,EA9Be,EA+BnC;;AACArD,UAAAA,EAAE,CAACsD,UAAH,CAAc,KAAd;AACMC,UAAAA,WAjC6B,GAiCfvD,EAAE,CAACyC,IAAH,CAAQ,MAAM;AAChC,kBAAMe,MAAM,GAAGxD,EAAE,CAACyD,QAAH,CAAYvC,KAAZ,EAAmB,CAAC8B,MAAM,CAAC,CAAD,CAAN,CAAUF,KAAV,CAAgB,CAAhB,CAAD,EAAqBE,MAAM,CAAC,CAAD,CAAN,CAAUF,KAAV,CAAgB,CAAhB,CAArB,CAAnB,CAAf;AACA,mBAAO9C,EAAE,CAAC0D,KAAH,CAASC,iBAAT,CACLH,MADK,EAELL,SAFK,EAGLd,gBAHK,EAILC,YAJK,EAKLC,cALK,CAAP;AAOD,WATmB,CAjCe;AA2C7BpB,UAAAA,OA3C6B,GA2CnBoC,WAAW,CAACN,QAAZ,EA3CmB;AA4CnCM,UAAAA,WAAW,CAACL,OAAZ,GA5CmC,CA6CnC;;AACAlD,UAAAA,EAAE,CAACsD,UAAH,CAAcF,WAAd;AA9CmC,2CAgD5BrC,oBAAoB,CACzBC,KADyB,EAEzBC,MAFyB,EAGzBC,KAHyB,EAIzBiC,SAJyB,EAKzBhC,OALyB,EAMzBX,OANyB,EAOzBY,MAPyB,CAhDQ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAA5Bc,4BAA4B;AAAA;AAAA;AAAA,GAAlC;;AA2DA,MAAM0B,2BAA2B;AAAA,uEAAG,kBAClCzB,KADkC,EAElCf,MAFkC,EAGlCgB,KAHkC,EAIlCyB,OAAO,GAAG,EAJwB;AAAA;AAAA;AAAA;AAAA;AAM5BrB,UAAAA,OAN4B,GAMlBxC,EAAE,CAACyC,IAAH,CAAQ,MAAM;AAC5B,kBAAMC,GAAG,GAAG1C,EAAE,CAAC2C,OAAH,CAAWC,UAAX,CAAsBR,KAAtB,CAAZ;AACA,kBAAM0B,KAAK,GAAG9D,EAAE,CAAC0D,KAAH,CAASK,cAAT,CAAwBrB,GAAxB,EAA6B,CAAC,GAAD,EAAM,GAAN,CAA7B,EAAyCsB,GAAzC,CAA6C,GAA7C,CAAd,CAF4B,CAI5B;;AACA,mBAAOF,KAAK,CAACjB,UAAN,CAAiB,CAAjB,EAAoBoB,OAApB,EAAP;AACD,WANe,CANkB;AAc5BC,UAAAA,OAd4B,GAclB/B,KAAK,CAACgC,OAAN,CAAc;AAAEC,YAAAA,WAAW,EAAE5B;AAAf,WAAd,CAdkB;AAgB5BpC,UAAAA,MAhB4B,GAgBnB8D,OAAO,CAACG,SAAR,GAAoB,CAApB,CAhBmB;AAkBlCH,UAAAA,OAAO,CAAChB,OAAR;AACAV,UAAAA,OAAO,CAACU,OAAR;AAEMoB,UAAAA,WArB4B,GAqBdlE,MAAM,CAACmE,GAAP,CAAW,CAACtC,KAAD,EAAQxB,CAAR,MAAe;AAC5CuB,YAAAA,KAAK,EAAEZ,MAAM,CAACX,CAAD,CAD+B;AAE5CwB,YAAAA,KAAK,EAAEA;AAFqC,WAAf,CAAX,CArBc;AA0BlCqC,UAAAA,WAAW,CAACE,IAAZ,CAAiB,CAACC,CAAD,EAAIC,CAAJ,KAAUA,CAAC,CAACzC,KAAF,GAAUwC,CAAC,CAACxC,KAAvC;AA1BkC,4CA4B3BqC,WA5B2B;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAA3BV,2BAA2B;AAAA;AAAA;AAAA,GAAjC;;AA+BA,MAAMe,gBAAgB,GAAG,CAAC,QAAD,EAAW,OAAX,EAAoB,OAApB,EAA6B,MAA7B,EAAqC,eAArC,CAAzB;AACA,MAAMC,iBAAiB,GAAG,CACxB,qBADwB,EAExB,qBAFwB,EAGxB,OAHwB,CAA1B;;AAMA,MAAMC,gBAAgB,GAAI1C,KAAD,IAAW;AAClC,SACE2C,MAAM,CAACC,MAAP,CAAc5C,KAAK,CAAC6C,QAAN,CAAe7C,KAAf,CAAqB8C,KAAnC,EAA0CC,IAA1C,CAAgDC,CAAD,IAC7CR,gBAAgB,CAACS,QAAjB,CAA0BD,CAAC,CAACE,EAA5B,CADF,MAEMC,SAHR;AAKD,CAND;;AAQA,eAAe;AACbC,EAAAA,IAAI;AAAA,yEAAE,kBAAOC,IAAP;AAAA;;AAAA;AAAA;AAAA;AACEC,YAAAA,SADF,GACcD,IAAI,GAAG,aADrB;AAEEE,YAAAA,UAFF,GAEeF,IAAI,GAAG,cAFtB;AAGEG,YAAAA,YAHF,GAGiB3F,EAAE,CAAC4F,cAAH,CAAkBH,SAAlB,CAHjB;AAIEI,YAAAA,aAJF,GAIkBC,KAAK,CAACJ,UAAD,CAAL,CAAkBK,IAAlB,CAAwBC,IAAD,IAAUA,IAAI,CAACC,IAAL,EAAjC,CAJlB;AAAA;AAAA,mBAK0BC,OAAO,CAACC,GAAR,CAAY,CAACR,YAAD,EAAeE,aAAf,CAAZ,CAL1B;;AAAA;AAAA;AAAA;AAKG1D,YAAAA,KALH;AAKUf,YAAAA,MALV;AAOEgF,YAAAA,iBAPF,GAOsBvB,gBAAgB,CAAC1C,KAAD,CAPtC,EASJ;;AATI,iBAUAiE,iBAVA;AAAA;AAAA;AAAA;;AAAA,8CAWK;AACLC,cAAAA,IAAI,EAAEpG,cADD;AAELqG,cAAAA,MAAM;AAAA,uFAAE,kBAAOlE,KAAP,EAAcyB,OAAd;AAAA;AAAA;AAAA;AAAA;AAAA,+BACA3B,4BAA4B,CAACC,KAAD,EAAQf,MAAR,EAAgBgB,KAAhB,EAAuByB,OAAvB,CAD5B;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAFD,aAXL;;AAAA;AAAA,8CAmBG;AACLwC,cAAAA,IAAI,EAAEnG,mBADD;AAELqG,cAAAA,QAAQ;AAAA,yFAAE,kBAAOnE,KAAP,EAAcyB,OAAd;AAAA;AAAA;AAAA;AAAA;AAAA,+BACFD,2BAA2B,CAACzB,KAAD,EAAQf,MAAR,EAAgBgB,KAAhB,EAAuByB,OAAvB,CADzB;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAFH,aAnBH;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AADS,CAAf","sourcesContent":["import * as tf from \"@tensorflow/tfjs\";\n\nconst TYPE_DETECTION = \"detection\";\nconst TYPE_CLASSIFICATION = \"classification\";\n\nconst calculateMaxScores = (scores, numBoxes, numClasses) => {\n  const maxes = [];\n  const classes = [];\n  for (let i = 0; i < numBoxes; i++) {\n    let max = Number.MIN_VALUE;\n    let index = -1;\n    for (let j = 0; j < numClasses; j++) {\n      if (scores[i * numClasses + j] > max) {\n        max = scores[i * numClasses + j];\n        index = j;\n      }\n    }\n    maxes[i] = max;\n    classes[i] = index;\n  }\n  return [maxes, classes];\n};\n\nconst buildDetectedObjects = (\n  width,\n  height,\n  boxes,\n  scores,\n  indexes,\n  classes,\n  labels\n) => {\n  const count = indexes.length;\n  const objects = [];\n  for (let i = 0; i < count; i++) {\n    const bbox = [];\n    for (let j = 0; j < 4; j++) {\n      bbox[j] = boxes[indexes[i] * 4 + j];\n    }\n    const minY = bbox[0] * height;\n    const minX = bbox[1] * width;\n    const maxY = bbox[2] * height;\n    const maxX = bbox[3] * width;\n    bbox[0] = minX;\n    bbox[1] = minY;\n    bbox[2] = maxX - minX;\n    bbox[3] = maxY - minY;\n    objects.push({\n      bbox: bbox,\n      class: labels[parseInt(classes[indexes[i]])], // deprecate.\n      label: labels[parseInt(classes[indexes[i]])],\n      score: scores[indexes[i]],\n    });\n  }\n  return objects;\n};\n\nconst runObjectDetectionPrediction = async (\n  graph,\n  labels,\n  input,\n  { maxNumberOfBoxes = 20, iouThreshold = 0.5, scoreThreshold = 0.5 } = {}\n) => {\n  const batched = tf.tidy(() => {\n    const img = tf.browser.fromPixels(input);\n    // Reshape to a single-element batch so we can pass it to executeAsync.\n    return img.expandDims(0);\n  });\n\n  const height = batched.shape[1];\n  const width = batched.shape[2];\n\n  const result = await graph.executeAsync(batched);\n\n  const scores = result[0].dataSync();\n  const boxes = result[1].dataSync();\n\n  // clean the webgl tensors\n  batched.dispose();\n  tf.dispose(result);\n\n  const [maxScores, classes] = calculateMaxScores(\n    scores,\n    result[0].shape[1],\n    result[0].shape[2]\n  );\n\n  const prevBackend = tf.getBackend();\n  // run post process in cpu\n  tf.setBackend(\"cpu\");\n  const indexTensor = tf.tidy(() => {\n    const boxes2 = tf.tensor2d(boxes, [result[1].shape[1], result[1].shape[3]]);\n    return tf.image.nonMaxSuppression(\n      boxes2,\n      maxScores,\n      maxNumberOfBoxes,\n      iouThreshold,\n      scoreThreshold\n    );\n  });\n  const indexes = indexTensor.dataSync();\n  indexTensor.dispose();\n  // restore previous backend\n  tf.setBackend(prevBackend);\n\n  return buildDetectedObjects(\n    width,\n    height,\n    boxes,\n    maxScores,\n    indexes,\n    classes,\n    labels\n  );\n};\n\nconst runClassificationPrediction = async (\n  graph,\n  labels,\n  input,\n  options = {}\n) => {\n  const batched = tf.tidy(() => {\n    const img = tf.browser.fromPixels(input);\n    const small = tf.image.resizeBilinear(img, [224, 224]).div(255);\n\n    // Reshape to a single-element batch so we can pass it to executeAsync.\n    return small.expandDims(0).toFloat();\n  });\n\n  const results = graph.execute({ Placeholder: batched });\n\n  const scores = results.arraySync()[0];\n\n  results.dispose();\n  batched.dispose();\n\n  const finalScores = scores.map((score, i) => ({\n    label: labels[i],\n    score: score,\n  }));\n\n  finalScores.sort((a, b) => b.score - a.score);\n\n  return finalScores;\n};\n\nconst CONTROL_FLOW_OPS = [\"Switch\", \"Merge\", \"Enter\", \"Exit\", \"NextIteration\"];\nconst DYNAMIC_SHAPE_OPS = [\n  \"NonMaxSuppressionV2\",\n  \"NonMaxSuppressionV3\",\n  \"Where\",\n];\n\nconst checkControlFlow = (graph) => {\n  return (\n    Object.values(graph.executor.graph.nodes).find((n) =>\n      CONTROL_FLOW_OPS.includes(n.op)\n    ) !== undefined\n  );\n};\n\nexport default {\n  load: async (path) => {\n    const graphPath = path + \"/model.json\";\n    const labelsPath = path + \"/labels.json\";\n    const graphPromise = tf.loadGraphModel(graphPath);\n    const labelsPromise = fetch(labelsPath).then((data) => data.json());\n    const [graph, labels] = await Promise.all([graphPromise, labelsPromise]);\n\n    const hasControlFlowOps = checkControlFlow(graph);\n\n    // If there are control flow ops it's probably object detection.\n    if (hasControlFlowOps) {\n      return {\n        type: TYPE_DETECTION,\n        detect: async (input, options) =>\n          await runObjectDetectionPrediction(graph, labels, input, options),\n      };\n    }\n\n    // Otherwise, probably classification.\n    return {\n      type: TYPE_CLASSIFICATION,\n      classify: async (input, options) =>\n        await runClassificationPrediction(graph, labels, input, options),\n    };\n  },\n};\n"]},"metadata":{},"sourceType":"module"}